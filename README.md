Модуль AI-ассистента (Neo OSI Backend)

## 1. Общее описание

Данный модуль является ядром интеллектуального ассистента в проекте **Neo OSI**. Его основная задача - автоматизация процесса создания юридических и бухгалтерских документов через интуитивно понятный диалоговый интерфейс. Модуль предоставляет API, которое позволяет фронтенд-приложению (PWA) вести многошаговый диалог с пользователем, собирать необходимые данные и генерировать на их основе готовые `.docx` файлы.

Это решение позволяет значительно сократить время на рутинные операции, минимизировать ошибки человеческого фактора и предоставить пользователям круглосуточный сервис по подготовке документов.

## 2. Ключевые возможности

- **Билингвальная поддержка (RU/KZ):** Система автоматически определяет язык пользователя и ведет весь диалог (ответы, вопросы, инструкции) на соответствующем языке.
- **Stateful (контекстный) диалог:** В отличие от простых чат-ботов, ассистент "помнит" контекст беседы. Он управляет состоянием пользователя, позволяя гибко переключаться между заполнением разных документов или выходить в режим общей консультации.
- **Динамическая генерация документов:** На основе выбранного шаблона AI генерирует уникальный список вопросов, а после получения данных формирует готовый `.docx` файл.
- **RAG (Retrieval-Augmented Generation):** Для ответов на общие вопросы используется векторная база знаний, созданная на основе нормативных документов. Это позволяет ассистенту давать консультации, основываясь на реальных данных, а не на общей информации из интернета.
- **Интегрированная бизнес-логика:** Реализована система тарифных планов ("Базовый", "Премиум") с ежемесячными лимитами на количество генерируемых документов.

## 3. Технологический стек

- **Backend:** NestJS, TypeScript
- **AI & LLM:** Google Gemini API (модели `gemini-1.5-pro` и `gemini-1.5-flash`), LangChain.js
- **Базы данных:** PostgreSQL (для хранения состояния пользователя и истории чата), In-memory Vector Store (для RAG)
- **Генерация документов:** `docxtemplater`
- **Prompt Engineering:** Разработана система многоуровневых промптов для решения задач определения намерений, генерации вопросов и извлечения структурированных данных.

## 4. Настройка и запуск

### 4.1. Предварительные требования
- Установлены Node.js (v18+), npm/yarn, Docker.
- Репозиторий проекта склонирован (`git clone -b dev ...`).
- Запущен контейнер с базой данных (`docker-compose up -d`).

### 4.2. Конфигурация
1. Создайте файл `.env` в корневой директории проекта.
2. Скопируйте в него содержимое из `example.env` или воспользуйтесь шаблоном ниже.
3. **Обязательно** заполните переменную `GEMINI_API_KEY` вашим ключом доступа к Google AI Studio.

```env
# Ключ для доступа к Google Gemini API
GEMINI_API_KEY=ВАШ_СЕКРЕТНЫЙ_КЛЮЧ_GEMINI

# Настройки подключения к базе данных (соответствуют docker-compose.yml)
DB_HOST=localhost
DB_PORT=5433
DB_USERNAME=admin
DB_PASSWORD=mysecretpassword
DB_DATABASE=neo_osi_db

# Секретный ключ для подписи JWT токенов
JWT_SECRET=THIS_IS_A_VERY_SECRET_AND_LONG_KEY_FOR_JWT
```

### **4.3. Установка зависимостей**

Перед первым запуском необходимо установить все зависимости проекта, указанные в `package.json`. В корневой директории выполните команду:
```bash
npm install
```

### **4.4. Кэширование базы знаний (Обязательный шаг)**

Для корректной работы RAG-системы (ответы на вопросы на основе документов) необходимо **один раз выполнить индексацию** PDF-файлов. Этот скрипт извлечет текст из всех PDF в папке `knowledge_base` и сохранит его в специальную папку `.pdf-cache`, которая используется для построения векторной базы знаний.

Выполните команду:
```bash
node cache-knowledge-base.js
```
Вы увидите в консоли логи обработки каждого файла. Дождитесь сообщения `--- КЭШИРОВАНИЕ ЗАВЕРШЕНО ---`.

**Важно:** Эту команду нужно выполнять **перед первым запуском** приложения, а также **каждый раз после добавления или изменения PDF-файлов** в папке `knowledge_base`, чтобы обновить базу знаний.

### **4.5. Запуск приложения**

После установки зависимостей и успешного кэширования базы знаний можно запустить сервер. Для локальной разработки используйте команду:
```bash
npm run start:dev
```
Сервис будет доступен по адресу `http://localhost:3000`.

## 5. API эндпоинты и использование

API сервера предоставляет несколько эндпоинтов, сгруппированных по функциональности. Базовый URL для всех запросов: `http://localhost:3000`.

**Аутентификация:** Большинство эндпоинтов защищены с помощью JWT. Для доступа к ним необходимо сначала получить токен через эндпоинт `/auth/login` и затем передавать его в заголовке `Authorization` каждого запроса:
`Authorization: Bearer ВАШ_JWT_ТОКЕН`

---

### 5.1. Аутентификация (`/auth`)

#### `POST /auth/login`
-   **Описание:** Аутентифицирует пользователя по email и паролю.
-   **Аутентификация:** Публичный.
-   **Тело запроса:**
    ```json
    {
      "email": "testuser@example.com",
      "password": "password123"
    }
    ```
-   **Успешный ответ (200 OK):**
    ```json
    {
      "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
    ```
-   **Ошибка (401 Unauthorized):** В случае неверного email или пароля.

---

### 5.2. Управление пользователями (`/users`)

#### `POST /users/register`
-   **Описание:** Создает нового пользователя в системе.
-   **Аутентификация:** Публичный.
-   **Тело запроса:**
    ```json
    {
      "email": "newuser@example.com",
      "password": "strongpassword"
    }
    ```
-   **Успешный ответ (201 Created):**
    ```json
    {
      "id": 1,
      "email": "newuser@example.com",
      "tariff": "Базовый",
      // ... другие поля пользователя
    }
    ```

#### `GET /users/profile`
-   **Описание:** Возвращает данные профиля текущего аутентифицированного пользователя.
-   **Аутентификация:** JWT требуется.
-   **Успешный ответ (200 OK):**
    ```json
    {
      "userId": 1,
      "email": "newuser@example.com",
      "tariff": "Базовый"
    }
    ```

#### `POST /users/reset-limit/:email`
-   **Описание:** **(Отладочный эндпоинт)** Сбрасывает лимит генерации документов для пользователя. Полезен для многократного тестирования сценария с лимитами.
-   **Аутентификация:** Публичный (для удобства тестирования).
-   **Параметр URL:** `email` - Email пользователя, которому нужно сбросить лимит.
-   **Успешный ответ (201 Created):**
    ```json
    {
      "message": "Лимит для пользователя newuser@example.com успешно сброшен.",
      "user": {
        "id": 1,
        "email": "newuser@example.com",
        "generation_count": 0
      }
    }
    ```
-   **Ошибка (404 Not Found):** Если пользователь с таким email не найден.

---

### 5.3. AI-ассистент (`/ai`)

#### `POST /ai/chat`
-   **Описание:** Основной эндпоинт для взаимодействия с AI. Через него происходит как обычный диалог, так и многошаговый процесс генерации документов.
-   **Аутентификация:** JWT требуется.
-   **Тело запроса:**
    ```json
    {
      "prompt": "Текст сообщения от пользователя"
    }
    ```
-   **Логика работы:**
    1.  **Начало генерации:** Если пользователь просит создать документ, сервер отвечает JSON-объектом с `action: 'collect_data'` и списком вопросов.
    2.  **Предоставление данных:** Пользователь отправляет данные в следующем запросе. Если данных достаточно, сервер возвращает `.docx` файл. Если нет — снова возвращает JSON с уточняющими вопросами.
    3.  **Обычный чат:** Если запрос не связан с генерацией, сервер возвращает JSON с текстовым ответом от AI.
    4.  **Смена контекста:** Если в процессе сбора данных пользователь просит сделать другой документ, сервер присылает новый список вопросов, не выходя из режима сбора данных.

*(Примеры запросов и ответов для этого эндпоинта подробно описаны в вашем руководстве по демонстрации)*.
