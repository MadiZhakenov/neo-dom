# Neo OSI Backend

Интеллектуальный бэкенд-сервис для AI-ассистента в сфере ЖКХ Казахстана.

## Описание

**Neo OSI Backend** — это ядро интеллектуального ассистента, разработанного для экосистемы **Neo OSI**. Проект представляет собой NestJS-приложение, которое предоставляет мощный API для решения двух ключевых задач:

1.  **"ИИ-Консультант"**: Предоставление точных и контекстуальных ответов на вопросы пользователей, касающиеся законодательства и стандартов в сфере ЖКХ и ОСИ, на основе собственной базы знаний.
2.  **"ИИ-Документы"**: Автоматизация процесса создания юридических и технических документов через интуитивно понятный диалоговый интерфейс.

Система разработана с акцентом на надежность, билингвальную поддержку (RU/KZ) и безопасность, обеспечивая бесшовный пользовательский опыт для фронтенд-приложений.

## Ключевые возможности

-   **Билингвальная поддержка:** Система автоматически определяет язык пользователя (русский, казахский, включая "шала-казахский") и ведет весь диалог на соответствующем языке.

-   **Продвинутый RAG-пайплайн:** Для ответов на вопросы используется многоуровневая система поиска (Retrieval-Augmented Generation), которая обеспечивает высокую точность и минимизирует "галлюцинации":
    -   **Жесткая маршрутизация:** Запросы по ключевым темам (ремонт, ОСИ, взносы) немедленно направляются на поиск в релевантных документах.
    -   **Гибридный поиск:** Комбинация поиска по ключевым словам и семантического (векторного) поиска.
    -   **Расширение контекста:** Система автоматически подгружает весь документ-источник, если найден хотя бы один релевантный фрагмент, чтобы исключить "разорванные" ответы.

-   **Персистентная база знаний:** Векторная база знаний хранится на диске с использованием `HNSWLib`, что обеспечивает быстрый старт приложения и стабильность результатов поиска.

-   **Динамическая генерация документов:** "ИИ-Документы" ведут многошаговый диалог с пользователем, собирают данные и генерируют на их основе готовые `.docx` файлы по шаблонам.

-   **Безопасная аутентификация:** Реализован надежный механизм `accessToken` + `refreshToken` для обеспечения долговременных и безопасных сессий.

-   **Интегрированная бизнес-логика:** Встроенная система подписок, где функция "ИИ-Документы" доступна только пользователям с активным **Премиум-статусом**.

## Технологический стек

-   **Backend:** [NestJS](https://nestjs.com/), [TypeScript](https://www.typescriptlang.org/)
-   **AI & LLM:** [Google Gemini API](https://ai.google.dev/) (модель `gemini-1.5-pro`), [LangChain.js](https://js.langchain.com/)
-   **Базы данных:**
    -   **Основная:** [PostgreSQL](https://www.postgresql.org/) с [TypeORM](https://typeorm.io/)
    -   **Векторная:** [HNSWLib](https://github.com/nmslib/hnswlib) для локального персистентного хранения векторов.
-   **Аутентификация:** [JWT](https://jwt.io/) (`accessToken` + `refreshToken`), [Passport.js](http://www.passportjs.org/)
-   **Генерация документов:** `docxtemplater`
-   **Деплоймент:** [Docker](https://www.docker.com/), [Render](https://render.com/)

## Архитектура системы

Проект построен на модульной архитектуре NestJS. Ключевые компоненты системы взаимодействуют следующим образом:

### 1. RAG-пайплайн (ИИ-Консультант)

Для ответов на вопросы пользователя применяется многоуровневый RAG-пайплайн, разработанный для максимальной точности.

**Пример запроса от пользователя:**
```json
// POST /ai/chat
{
  "prompt": "Что такое текущий ремонт?"
}
```

**Как система обрабатывает этот запрос:**

1.  **Маршрутизация по ключевым словам (`keywordToFileMap`):**
    -   Система находит в запросе ключевое слово "текущий ремонт" и по своим внутренним правилам определяет, что ответ, скорее всего, находится в файлах `СТ РК 2864-2016.pdf.txt` и `Закон... .pdf.txt`. Поиск сужается до этих источников.

2.  **Гибридный поиск в документах (`_getRelevantDocs`):**
    -   **Keyword Search:** Внутри этих двух файлов система ищет фрагменты, где есть точное совпадение "текущий ремонт".
    -   **Vector Search:** Параллельно по всему индексу `HNSWLib` ищется смысловая близость. Результаты, не относящиеся к выбранным файлам, отбрасываются.
    -   **Ранжирование:** Результаты обоих поисков объединяются.

3.  **Расширение контекста (FULL_DOC Expansion):**
    -   Система видит, что был найден релевантный фрагмент из `СТ РК 2864-2016.pdf.txt`.
    -   Она немедленно подгружает в контекст **весь текст** этого стандарта целиком, чтобы гарантировать, что определение не будет "разорвано".

4.  **Генерация ответа (`_generateFinalAnswer`):**
    -   Собранный, объемный контекст и строгие инструкции передаются в Google Gemini для генерации финального ответа, который будет выглядеть примерно так: `"Согласно СТ РК 2864-2016, текущий ремонт здания — это..."`.

### 2. Генерация документов (ИИ-Документы)

Этот процесс управляется `DocumentAiService` и следует логике конечного автомата, где состояние пользователя хранится в БД (`users.doc_chat_...`).

**Пример диалога:**

1.  **Распознавание намерения и выбор шаблона:**
    -   Пользователь отправляет:
        ```json
        // POST /ai/documents
        { "prompt": "Хочу оформить акт приема-передачи" }
        ```
    -   Система определяет намерение, находит наиболее подходящий шаблон и сохраняет его имя (`forma-akta-priyema-peredachi... .docx`) в профиль пользователя.

2.  **Генерация вопросов:**
    -   AI анализирует переменные (`{address}`, `{sender_fio}`) в `.docx` шаблоне и генерирует список вопросов.
    -   Ответ пользователю:
        ```json
        {
          "aiResponse": {
            "action": "collect_data",
            "message": "Для заполнения документа 'Форма акта...' потребуется следующая информация:\n1. Укажите адрес объекта.\n2. ... (и т.д.)"
          }
        }
        ```

3.  **Сбор данных:**
    -   Пользователь отвечает на вопросы. Система парсит ответы и сохраняет их в `user.doc_chat_pending_data` в виде JSON: `{"address": "г. Астана...", "sender_fio": "Иванов И.И."}`.
    -   Каждый раз система задает следующий вопрос, пока не соберет все данные.

4.  **Финальная генерация:**
    -   Когда все данные собраны, они подставляются в `.docx` шаблон.
    -   Сервер возвращает **бинарный файл**, который фронтенд предлагает пользователю скачать.

### 3. Аутентификация

Система использует двух-токенную JWT-схему для безопасности и удобства.

**Пример получения токенов:**
```json
// POST /auth/login
{
  "email": "test@user.com",
  "password": "password123"
}
// Ответ:
{
  "accessToken": "...",  // Живет 1 час, используется для всех запросов
  "refreshToken": "..." // Живет 7 дней, используется только для /auth/refresh
}
```

**Пример обновления токенов:**
```json
// POST /auth/refresh
// Headers: Authorization: Bearer <ВАШ_REFRESH_TOKEN>
// Body: (пустое)
// Ответ:
{
  "accessToken": "НОВЫЙ_...",
  "refreshToken": "НОВЫЙ_..."
}
```
Это обеспечивает долговременную сессию без необходимости повторного ввода пароля.
```