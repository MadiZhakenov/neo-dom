# Neo OSI Backend

Интеллектуальный бэкенд-сервис для AI-ассистента в сфере ЖКХ Казахстана.

## Описание

**Neo OSI Backend** — это ядро интеллектуального ассистента, разработанного для экосистемы **Neo OSI**. Проект представляет собой NestJS-приложение, которое предоставляет мощный API для решения двух ключевых задач:

1.  **"ИИ-Консультант"**: Предоставление точных и контекстуальных ответов на вопросы пользователей, касающиеся законодательства и стандартов в сфере ЖКХ и ОСИ, на основе собственной базы знаний.
2.  **"ИИ-Документы"**: Автоматизация процесса создания юридических и технических документов через интуитивно понятный диалоговый интерфейс.

Система разработана с акцентом на надежность, билингвальную поддержку (RU/KZ) и безопасность, обеспечивая бесшовный пользовательский опыт для фронтенд-приложений.

## Ключевые возможности

-   **Билингвальная поддержка:** Система автоматически определяет язык пользователя (русский, казахский, включая "шала-казахский") и ведет весь диалог на соответствующем языке.

-   **Продвинутый RAG-пайплайн:** Для ответов на вопросы используется многоуровневая система поиска (Retrieval-Augmented Generation), которая обеспечивает высокую точность и минимизирует "галлюцинации":
    -   **Жесткая маршрутизация:** Запросы по ключевым темам (ремонт, ОСИ, взносы) немедленно направляются на поиск в релевантных документах.
    -   **Гибридный поиск:** Комбинация поиска по ключевым словам и семантического (векторного) поиска.
    -   **Расширение контекста:** Система автоматически подгружает весь документ-источник, если найден хотя бы один релевантный фрагмент, чтобы исключить "разорванные" ответы.

-   **Персистентная база знаний:** Векторная база знаний хранится на диске с использованием `HNSWLib`, что обеспечивает быстрый старт приложения и стабильность результатов поиска.

-   **Динамическая генерация документов:** "ИИ-Документы" ведут многошаговый диалог с пользователем, собирают данные и генерируют на их основе готовые `.docx` файлы по шаблонам.

-   **Безопасная аутентификация:** Реализован надежный механизм `accessToken` + `refreshToken` для обеспечения долговременных и безопасных сессий.

-   **Интегрированная бизнес-логика:** Встроенная система подписок, где функция "ИИ-Документы" доступна только пользователям с активным **Премиум-статусом**.

## Технологический стек

-   **Backend:** [NestJS](https://nestjs.com/), [TypeScript](https://www.typescriptlang.org/)
-   **AI & LLM:** [Google Gemini API](https://ai.google.dev/) (модель `gemini-1.5-pro`), [LangChain.js](https://js.langchain.com/)
-   **Базы данных:**
    -   **Основная:** [PostgreSQL](https://www.postgresql.org/) с [TypeORM](https://typeorm.io/)
    -   **Векторная:** [HNSWLib](https://github.com/nmslib/hnswlib) для локального персистентного хранения векторов.
-   **Аутентификация:** [JWT](https://jwt.io/) (`accessToken` + `refreshToken`), [Passport.js](http://www.passportjs.org/)
-   **Генерация документов:** `docxtemplater`
-   **Деплоймент:** [Docker](https://www.docker.com/), [Render](https://render.com/)

## Архитектура системы

Проект построен на модульной архитектуре NestJS. Ключевые компоненты системы взаимодействуют следующим образом:

### 1. RAG-пайплайн (ИИ-Консультант)

Для ответов на вопросы пользователя применяется многоуровневый RAG-пайплайн, разработанный для максимальной точности.

**Пример запроса от пользователя:**
```json
// POST /ai/chat
{
  "prompt": "Что такое текущий ремонт?"
}
```

**Как система обрабатывает этот запрос:**

1.  **Маршрутизация по ключевым словам (`keywordToFileMap`):**
    -   Система находит в запросе ключевое слово "текущий ремонт" и по своим внутренним правилам определяет, что ответ, скорее всего, находится в файлах `СТ РК 2864-2016.pdf.txt` и `Закон... .pdf.txt`. Поиск сужается до этих источников.

2.  **Гибридный поиск в документах (`_getRelevantDocs`):**
    -   **Keyword Search:** Внутри этих двух файлов система ищет фрагменты, где есть точное совпадение "текущий ремонт".
    -   **Vector Search:** Параллельно по всему индексу `HNSWLib` ищется смысловая близость. Результаты, не относящиеся к выбранным файлам, отбрасываются.
    -   **Ранжирование:** Результаты обоих поисков объединяются.

3.  **Расширение контекста (FULL_DOC Expansion):**
    -   Система видит, что был найден релевантный фрагмент из `СТ РК 2864-2016.pdf.txt`.
    -   Она немедленно подгружает в контекст **весь текст** этого стандарта целиком, чтобы гарантировать, что определение не будет "разорвано".

4.  **Генерация ответа (`_generateFinalAnswer`):**
    -   Собранный, объемный контекст и строгие инструкции передаются в Google Gemini для генерации финального ответа, который будет выглядеть примерно так: `"Согласно СТ РК 2864-2016, текущий ремонт здания — это..."`.

### 2. Генерация документов (ИИ-Документы)

Этот процесс управляется `DocumentAiService` и следует логике конечного автомата, где состояние пользователя хранится в БД (`users.doc_chat_...`).

**Пример диалога:**

1.  **Распознавание намерения и выбор шаблона:**
    -   Пользователь отправляет:
        ```json
        // POST /ai/documents
        { "prompt": "Хочу оформить акт приема-передачи" }
        ```
    -   Система определяет намерение, находит наиболее подходящий шаблон и сохраняет его имя (`forma-akta-priyema-peredachi... .docx`) в профиль пользователя.

2.  **Генерация вопросов:**
    -   AI анализирует переменные (`{address}`, `{sender_fio}`) в `.docx` шаблоне и генерирует список вопросов.
    -   Ответ пользователю:
        ```json
        {
          "aiResponse": {
            "action": "collect_data",
            "message": "Для заполнения документа 'Форма акта...' потребуется следующая информация:\n1. Укажите адрес объекта.\n2. ... (и т.д.)"
          }
        }
        ```

3.  **Сбор данных:**
    -   Пользователь отвечает на вопросы. Система парсит ответы и сохраняет их в `user.doc_chat_pending_data` в виде JSON: `{"address": "г. Астана...", "sender_fio": "Иванов И.И."}`.
    -   Каждый раз система задает следующий вопрос, пока не соберет все данные.

4.  **Финальная генерация:**
    -   Когда все данные собраны, они подставляются в `.docx` шаблон.
    -   Сервер возвращает **бинарный файл**, который фронтенд предлагает пользователю скачать.

### 3. Аутентификация

Система использует двух-токенную JWT-схему для безопасности и удобства.

**Пример получения токенов:**
```json
// POST /auth/login
{
  "email": "test@user.com",
  "password": "password123"
}
// Ответ:
{
  "accessToken": "...",  // Живет 1 час, используется для всех запросов
  "refreshToken": "..." // Живет 7 дней, используется только для /auth/refresh
}
```

**Пример обновления токенов:**
```json
// POST /auth/refresh
// Headers: Authorization: Bearer <ВАШ_REFRESH_TOKEN>
// Body: (пустое)
// Ответ:
{
  "accessToken": "НОВЫЙ_...",
  "refreshToken": "НОВЫЙ_..."
}
```

## Настройка и запуск

### 5.1. Предварительные требования

-   [Node.js](https://nodejs.org/) (рекомендуется версия v18.x или выше)
-   [npm](https://www.npmjs.com/) (обычно идет в комплекте с Node.js)
-   [Docker](https://www.docker.com/) и Docker Compose

### 5.2. Установка

1.  **Клонируйте репозиторий:**
    ```bash
    git clone <URL_ВАШЕГО_РЕПОЗИТОРИЯ>
    cd neo-osi-backend
    ```

2.  **Создайте `.env` файл:**
    Скопируйте файл `.env.example` (если он есть) или создайте новый файл `.env` в корневой директории проекта и заполните его по шаблону ниже.

    ```env
    #---------------------------------
    # API Ключи
    #---------------------------------
    # Ключ для доступа к Google Gemini API
    GEMINI_API_KEY=ВАШ_СЕКРЕТНЫЙ_КЛЮЧ_GEMINI
    
    # Секретные ключи для подписи JWT токенов (ДОЛЖНЫ БЫТЬ РАЗНЫМИ И СЛОЖНЫМИ)
    JWT_SECRET=СЕКРЕТНЫЙ_КЛЮЧ_ДЛЯ_ACCESS_TOKEN
    JWT_REFRESH_SECRET=ДРУГОЙ_СЕКРЕТНЫЙ_КЛЮЧ_ДЛЯ_REFRESH_TOKEN
    
    # Время жизни accessToken для тестов (например, 60s, 5m, 1h). 
    # В проде эту строку можно убрать (по умолчанию будет 1 час).
    JWT_ACCESS_TOKEN_EXPIRATION=5m

    #---------------------------------
    # База данных (соответствуют docker-compose.yml)
    #---------------------------------
    DB_HOST=localhost
    DB_PORT=5433
    DB_USERNAME=admin
    DB_PASSWORD=mysecretpassword
    DB_DATABASE=neo_osi_db
    ```

3.  **Установите зависимости:**
    Из-за особенностей зависимостей в `langchain` рекомендуется использовать флаг `--legacy-peer-deps`.
    ```bash
    npm install --legacy-peer-deps
    ```

### 5.3. Работа с базой данных

Проект использует Docker для запуска базы данных PostgreSQL.

1.  **Запустите контейнер с БД:**
    Эта команда запустит базу данных в фоновом режиме.
    ```bash
    docker-compose up -d
    ```

2.  **Примените миграции:**
    После первого запуска базы данных необходимо создать в ней все таблицы.
    ```bash
    npm run migration:run:local
    ```
    Эту команду также нужно выполнять после каждой новой сгенерированной миграции.

### 5.4. Кэширование и индексация (Критически важный шаг)

Для работы "ИИ-Консультанта" необходимо подготовить базу знаний.

1.  **Поместите PDF-файлы:** Убедитесь, что все ваши нормативные документы в формате `.pdf` находятся в папке `knowledge_base`.

2.  **Создайте текстовый кэш:** Этот скрипт извлечет текст из всех PDF и сохранит его в `.pdf-cache`.
    ```bash
    npm run cache
    ```

3.  **Создайте/обновите поисковый индекс:** После запуска приложения оно автоматически создаст или загрузит персистентный поисковый индекс (`HNSWLib`) в папку `.rag-index`.

    **Важно:** Если вы **добавили, изменили или удалили PDF-файлы** и заново запустили `npm run cache`, вам необходимо **удалить старый индекс**, чтобы он пересоздался на основе новых текстов. Просто удалите папку `.rag-index` перед следующим запуском сервера.

### 5.5. Запуск приложения

После выполнения всех шагов можно запустить сервер в режиме разработки:
```bash
npm run start:dev
```
Сервер будет доступен по адресу `http://localhost:3000`. При первом запуске он создаст поисковый индекс, что может занять несколько минут. Последующие запуски будут почти мгновенными.

Отлично. Приступаем к самому большому и важному разделу. Мы опишем **каждый** эндпоинт, чтобы у Санжара (и у любого другого разработчика) не осталось ни одного вопроса.

Начнем с **Аутентификации** и **Пользователей**.

---

### 6. Полное Описание API Эндпоинтов

Все эндпоинты доступны по базовому URL, который зависит от окружения (например, `http://localhost:3000` для локальной разработки).

Для доступа к защищенным эндпоинтам необходимо в каждом запросе передавать заголовок `Authorization` с `accessToken`:
`Authorization: Bearer <ВАШ_ACCESS_TOKEN>`

### 6.1. Аутентификация (`/auth`)

Этот модуль отвечает за вход, выход и управление сессиями.

---
#### `POST /auth/login`
-   **Описание:** Аутентифицирует пользователя по email и паролю.
-   **Аутентификация:** Публичный.
-   **Тело запроса (`Body`):**
    ```json
    {
      "email": "test@example.com",
      "password": "password123"
    }
    ```
-   **Успешный ответ (`201 Created`):** Возвращает пару токенов для управления сессией.
    ```json
    {
      "accessToken": "eyJhbGciOi...", // Короткоживущий, для обычных запросов
      "refreshToken": "eyJhbGciOi..." // Долгоживущий, для обновления сессии
    }
    ```
-   **Ошибка (`401 Unauthorized`):** В случае неверного email или пароля.

---
#### `POST /auth/refresh`
-   **Описание:** Обновляет истекший `accessToken`, используя `refreshToken`.
-   **Аутентификация:** Специальная. Требует `refreshToken` в заголовке.
    -   `Authorization: Bearer <ВАШ_REFRESH_TOKEN>`
-   **Тело запроса (`Body`):** Пустое.
-   **Успешный ответ (`201 Created`):** Возвращает **новую** пару токенов.
    ```json
    {
      "accessToken": "НОВЫЙ_...",
      "refreshToken": "НОВЫЙ_..."
    }
    ```
-   **Ошибка (`401 Unauthorized`):** Если `refreshToken` невалиден или истек.

---
#### `POST /auth/logout`
-   **Описание:** Завершает сессию пользователя, делая `refreshToken` недействительным.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`201 Created`):** Пустое тело.

---
#### `POST /auth/forgot-password`
-   **Описание:** Инициирует процедуру сброса пароля. Отправляет на email пользователя письмо со ссылкой.
-   **Аутентификация:** Публичный.
-   **Тело запроса (`Body`):**
    ```json
    {
      "email": "user_who_forgot@example.com"
    }
    ```
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "message": "Если такой пользователь существует, ему будет отправлена ссылка для сброса пароля."
    }
    ```
    *(Ответ всегда одинаковый, чтобы не раскрывать, существует ли email в базе).*

---
#### `POST /auth/reset-password`
-   **Описание:** Устанавливает новый пароль, используя токен из письма.
-   **Аутентификация:** Публичный.
-   **Тело запроса (`Body`):**
    ```json
    {
      "token": "токен_из_ссылки_в_письме",
      "password": "МойНовыйНадежныйПароль"
    }
    ```
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "message": "Пароль успешно обновлен."
    }
    ```

---
#### `GET /auth/reset-password`
-   **Описание:** Эндпоинт, на который ведет ссылка из письма. Он **не выполняет действий**, а просто рендерит HTML-страницу для ввода нового пароля.
-   **Аутентификация:** Публичный.
-   **Параметры запроса (`Query Params`):**
    -   `token`: Токен для сброса.
    -   Пример URL: `https://neo-osi-backend.onrender.com/auth/reset-password?token=abcdef123...`

---

### 6.2. Управление пользователями (`/users`)

Этот модуль отвечает за регистрацию и управление данными пользователей.

---
#### `POST /users/register`
-   **Описание:** Создает нового пользователя в системе.
-   **Аутентификация:** Публичный.
-   **Тело запроса (`Body`):**
    ```json
    {
      "email": "newuser@example.com",
      "password": "strongpassword"
    }
    ```
-   **Успешный ответ (`201 Created`):** Возвращает созданный объект пользователя (без пароля).
    ```json
    {
      "id": 123,
      "email": "newuser@example.com",
      "tariff": "Базовый",
      // ... другие поля
    }
    ```

---
#### `GET /users/profile`
-   **Описание:** Возвращает данные профиля текущего аутентифицированного пользователя.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`200 OK`):**
    ```json
    {
      "id": 123,
      "email": "newuser@example.com",
      "fullName": "Иван Иванов",
      "phone": "+77001234567",
      "role": "resident",
      "subscription": {
        "isActive": true,
        "expiresAt": "2025-09-15T12:00:00.000Z"
      }
    }
    ```

---
#### `POST /users/change-password`
-   **Описание:** Позволяет залогиненному пользователю сменить свой пароль.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Тело запроса (`Body`):**
    ```json
    {
      "oldPassword": "мой_старый_пароль",
      "newPassword": "мой_новый_супер_пароль"
    }
    ```
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "message": "Пароль успешно изменен."
    }
    ```

---
#### `POST /users/reset-limit/:email`
-   **Описание:** **(Отладочный эндпоинт)** Сбрасывает лимит генерации документов для пользователя.
-   **Аутентификация:** Публичный (для удобства тестирования).
-   **Параметр URL:** `email` пользователя.
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "message": "Лимит для пользователя newuser@example.com успешно сброшен."
    }
    ```
---